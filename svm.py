# -*- coding: utf-8 -*-
"""SVM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NI3NMW61SDzFGuh4t0uYlx_jK95awD26
"""

#εγκατάστση της βιβλιοθήκης scikit-image matplotlib
pip install scikit-image matplotlib

#εγκατάστση της βιβλιοθήκης idx2numpy
pip install idx2numpy

#εισαγωγή αναγκαίων βιβλιοθηκών
import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import gzip
import seaborn as sns
import idx2numpy
from sklearn import metrics


from sklearn import svm
from skimage.feature import hog
from skimage import exposure
from skimage.transform import resize
from PIL import Image
from skimage.io import imread

#άνοιγμα αρχείων με gzip
train_zip = gzip.open('/content/train-images-idx3-ubyte.gz','r')
train_labels_zip = gzip.open('/content/train-labels-idx1-ubyte.gz','r')
test_zip  = gzip.open('/content/t10k-images-idx3-ubyte.gz','r')
test_labels_zip = gzip.open('/content/t10k-labels-idx1-ubyte.gz','r')

#διάβασμα των αρχείων
imagefile1 = train_zip
train = idx2numpy.convert_from_file(imagefile1)

imagefile2 = train_labels_zip
trainlabels = idx2numpy.convert_from_file(imagefile2)

imagefile3 = test_zip
test = idx2numpy.convert_from_file(imagefile3)

imagefile4 = test_labels_zip
testlabels = idx2numpy.convert_from_file(imagefile4)

#οπτικοποίηση ενός τυχαίου παραδείγματος που εμπεριέχεται στο train
sample = 1
image = train[sample]

fig = plt.figure
plt.imshow(image, cmap= 'Greys')
plt.show()

#οι διαστάσεις μιας εικόνας του train
image.shape

#εφαρμογή του φίλτρου HOG για τις εικόνες που περιέχονται στο train 
train_hoggedimages = []
trainhog = []


for i in range(len(train)):


  fd, hoggedimage = hog(train[i], orientations=9, pixels_per_cell=(4, 4),
                	cells_per_block=(2, 2), visualize=True, multichannel=False)
	
  train_hoggedimages.append(hoggedimage)

  trainhog.append(fd)


train_hoggedimages = np.array(train_hoggedimages)
trainhog = np.array(trainhog)

#διαστάσεις του πίνακα που περιέχει τους περιγραφείς HOG για τις εικόνες του train
trainhog.shape

#διαστάσεις του περιγραφέα HOG για μία εικόνα
trainhog[0].shape

#διαστάσεις του πίνακα που περιέχει τις μετασχηματισμένες εικόνες, μετά την εφαρμογή του HOG φίλτρου
train_hoggedimages.shape

#διαστάσεις μία εικόνας που προκύπτει μετά την εφαρμογή του HOG φίλτρου
train_hoggedimages[0].shape

plt.style.use('default')

#οπτικοποίηση της εφαρμογής του HOG φίλτρου σε μία εικόνα
sample = 50
image = train[sample]
hogimage = train_hoggedimages[sample]
fd = trainhog[sample]


fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(20, 7), sharex=False, sharey=False) 

#fig.subplots_adjust(hspace=0.4, top=1.2)

fig.suptitle("Application of HOG filter to an image representing a 3, using patch size 4*4", fontsize=20)

ax1.imshow(image, cmap = 'Greys') 
ax1.set_title('Input image', fontsize = 15) 

ax2.imshow(hogimage, cmap = 'Greys') 
ax2.set_title('Visualization of HOGed Image', fontsize = 15)

ax3.plot(fd) 
ax3.set_title('Image HOG Descriptor', fontsize = 15)




plt.show()

#καθορισμός του y_train
y_train = trainlabels

#καθορισμός του X_train
X_train = trainhog

#διαστάσεις του X_train
X_train.shape

#εφαρμογή του svm με πυρήνα rbf
from sklearn import svm
rbf = svm.SVC(kernel  = 'rbf', decision_function_shape='ovr')
rbf.fit(X_train, y_train)

#εφαρμογή του svm με πυρήνα πολυωνυμικό
from sklearn import svm
poly = svm.SVC(kernel  = 'poly', decision_function_shape='ovr')
poly.fit(X_train, y_train)

#εφαρνογή του svm με πυρήνα γραμμικό
from sklearn import svm
linear = svm.LinearSVC(dual=False, multi_class = 'ovr')
linear.fit(X_train, y_train)

#εφαρμογή του ΗOG φίλτρου σις εικόνες του test
testhog = []
test_hoggedimages = []

for i in range(len(test)):


  fd, hoggedimage = hog(test[i], orientations=9, pixels_per_cell=(4, 4),
                	cells_per_block=(2, 2), visualize=True, multichannel=False)
	

  test_hoggedimages.append(hoggedimage)

  testhog.append(fd)




test_hoggedimages = np.array(test_hoggedimages)

testhog = np.array(testhog)

#καθορισμός του X_test
X_test = testhog

#προβλέψεις του svm με τον rbf πυρήνα
predictionsr = rbf.predict(X_test)

#προβλέψεις του svm με τον πολυωνυμικό πυρήνα
predictionsp  = poly.predict(X_test)

#προβλέψεις του svm με τον γραμμικό πυρήνα
predictionsl = linear.predict(X_test)

print(predictionsp[0:10])
print(testlabels[0:10])

#ακρίβεια ταξινόμησης του svm με τον rbf πυρήνα
accuracy = metrics.accuracy_score(predictionsr, testlabels)
print('Accuracy with the rbf kernel is', accuracy)

#ακρίβεια ταξινόμησης του svm με τον πολυωνυμικό πυρήνα
accuracy = metrics.accuracy_score(predictionsp, testlabels)
print('Accuracy with the polynomial kernel is', accuracy)

#ακρίβεια ταξινόμησης του svm με τον γραμμικό πυρήνα
accuracy = metrics.accuracy_score(predictionsl, testlabels)
print('Accuracy with the linear kernel is', accuracy)

#εντοπισμός των λανθασμένων προβλέψεων
false_predictions = []

for i in range(10000):

  if predictionsp[i] != testlabels[i]:

    false_predictions.append(i)

#εντοπισμός των σωστών προβλέψεων
true_predictions = []

for i in range(10000):

  if predictionsp[i] == testlabels[i]:

    true_predictions.append(i)

#οπτικοποίηση για δέκα ψευδείς προβλέψεις
num_row = 2
num_col = 5

j = 10

fig, axes = plt.subplots(num_row, num_col, figsize=(3.5*num_col, 4.5*num_row))


fig.subplots_adjust(hspace=0.4, top=1.2)

fig.suptitle("Instances of falsely classified digits", fontsize = 19)


for i in range(j):

 ax = axes[i//num_col, i%num_col]
 ax.imshow(test[false_predictions[i]], cmap='gray')
 ax.set_title('Predicted Label: {},True Label: {}'.format(predictionsp[false_predictions[i]], testlabels[false_predictions[i]]), fontsize  = 14)



plt.tight_layout()
plt.show()

#οπτικοποίηση για δέκα αληθείς προβλέψεις
num_row = 2
num_col = 5

j =10

fig, axes = plt.subplots(num_row, num_col, figsize=(3*num_col,4*num_row))


fig.subplots_adjust(hspace=0.4, top=1.2)

fig.suptitle("Instances of correctly classified digits", fontsize = 16)


for i in range(j):

  ax = axes[i//num_col, i%num_col]
  ax.imshow(test[true_predictions[i]], cmap='gray')
  ax.set_title('True Predicted Label: {}'.format(predictionsp[true_predictions[i]]), fontsize = 15)



plt.tight_layout()
plt.show()

#συνάρτηση δημιουργίας του πίνακα συνάφειας
def conf_matr(actual, predicted):

  shape = (10,10)
  confusion_matrix = np.zeros(shape)

  for i in range(10000):
    confusion_matrix[actual[i], predicted[i]]+=1


  confusion_matrix = confusion_matrix.astype(int)
  return confusion_matrix

#ο πίνακας συνάφειας
confusion_matrix = conf_matr(testlabels, predictionsp)
confusion_matrix

#μετατροπή του πίνακα συνάφειας, ώστε να περιέχει ποσοστά για κάθε ψηφίο
confusion_matrix  = confusion_matrix.astype(np.float)

for i in range(10):

     confusion_matrix[i] = confusion_matrix[i]/sum(confusion_matrix[i])


confusion_matrix = np.round(confusion_matrix, 3)

#τελική μορφή πίνακα συνάφειας
fig = plt.figure(figsize = (20,9))
ax = plt.subplot()

sns.set(font_scale=1.8)
sns.heatmap(confusion_matrix, annot=True, fmt='', cmap='Blues')

ax.set_xlabel('predicted', fontsize = 15)
ax.set_ylabel('true',fontsize = 15) 

plt.title('Confusion Matrix', fontsize = 20)

plt.show()